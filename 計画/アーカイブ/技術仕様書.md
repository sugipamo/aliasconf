# AliasConf æŠ€è¡“ä»•æ§˜æ›¸

**ä½œæˆæ—¥**: 2024å¹´7æœˆ3æ—¥  
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 1.0  
**å¯¾è±¡**: é–‹ç™ºè€…ãƒ»ã‚³ãƒ³ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ã‚¿ãƒ¼

## ğŸ“‹ æ¦‚è¦

AliasConf ã¯ Python å‘ã‘ã®è¨­å®šç®¡ç†ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã€è¤‡æ•°ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ï¼ˆåˆ¥åï¼‰ã‚’é€šã˜ã¦åŒä¸€ã®è¨­å®šå€¤ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ç‹¬è‡ªæ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ã€‚

## ğŸ—ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆå›³
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ConfigManager â”‚â”€â”€â”€â”€â”‚   ConfigResolver â”‚â”€â”€â”€â”€â”‚   ConfigNode    â”‚
â”‚  (High Level)   â”‚    â”‚   (Resolution)   â”‚    â”‚  (Tree Node)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                        â”‚                        â”‚
         â”‚                        â”‚                        â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Utils       â”‚    â”‚   Formatters     â”‚    â”‚   Exceptions    â”‚
â”‚   (Helpers)     â”‚    â”‚  (Templates)     â”‚    â”‚   (Errors)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ãƒ¬ã‚¤ãƒ¤ãƒ¼æ§‹æˆ

#### 1. Presentation Layer (ConfigManager)
- **è²¬å‹™**: ãƒ¦ãƒ¼ã‚¶ãƒ¼å‘ã‘ã®é«˜ãƒ¬ãƒ™ãƒ«APIæä¾›
- **ä¸»è¦æ©Ÿèƒ½**: ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã€è¨­å®šã‚¢ã‚¯ã‚»ã‚¹ã€å‹å¤‰æ›
- **ä¾å­˜é–¢ä¿‚**: ConfigResolver, Utils

#### 2. Business Layer (ConfigResolver)  
- **è²¬å‹™**: è¨­å®šè§£æ±ºãƒ­ã‚¸ãƒƒã‚¯ã€ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè£…
- **ä¸»è¦æ©Ÿèƒ½**: ãƒ‘ã‚¹è§£æ±ºã€ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå±•é–‹ã€ãƒãƒƒãƒãƒ³ã‚°
- **ä¾å­˜é–¢ä¿‚**: ConfigNode, Formatters

#### 3. Domain Layer (ConfigNode)
- **è²¬å‹™**: è¨­å®šãƒ‡ãƒ¼ã‚¿ã®æ§‹é€ å®šç¾©ã€åŸºæœ¬æ“ä½œ
- **ä¸»è¦æ©Ÿèƒ½**: æœ¨æ§‹é€ ã€ã‚¨ã‚¤ãƒªã‚¢ã‚¹ç®¡ç†ã€BFSæ¢ç´¢
- **ä¾å­˜é–¢ä¿‚**: ãªã—ï¼ˆç´”ç²‹ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«ï¼‰

#### 4. Infrastructure Layer (Utils, Formatters, Exceptions)
- **è²¬å‹™**: å…±é€šæ©Ÿèƒ½ã€è£œåŠ©æ©Ÿèƒ½ã€ã‚¨ãƒ©ãƒ¼å‡¦ç†
- **ä¸»è¦æ©Ÿèƒ½**: ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ã€ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå‡¦ç†ã€ä¾‹å¤–å®šç¾©
- **ä¾å­˜é–¢ä¿‚**: ç›¸äº’ä¾å­˜ãªã—

## ğŸ”§ è©³ç´°è¨­è¨ˆ

### ConfigNode (ã‚³ã‚¢ãƒ‡ãƒ¼ã‚¿æ§‹é€ )

#### ã‚¯ãƒ©ã‚¹å®šç¾©
```python
class ConfigNode:
    def __init__(self, key: str, value: Optional[Any]):
        self.key: str                           # ãƒãƒ¼ãƒ‰ã®ã‚­ãƒ¼
        self.value: Optional[Any]               # è¨­å®šå€¤
        self.parent: Optional[ConfigNode]       # è¦ªãƒãƒ¼ãƒ‰
        self.next_nodes: list[ConfigNode]       # å­ãƒãƒ¼ãƒ‰ä¸€è¦§
        self.matches: set[str]                  # ãƒãƒƒãƒã™ã‚‹ã‚­ãƒ¼é›†åˆ
```

#### ã‚¨ã‚¤ãƒªã‚¢ã‚¹æ©Ÿèƒ½ã®å®Ÿè£…
```python
# ã‚¨ã‚¤ãƒªã‚¢ã‚¹åˆæœŸåŒ–
def init_matches(node: ConfigNode, value: Any):
    if isinstance(value, dict) and "aliases" in value:
        aliases = value["aliases"]
        for alias in aliases:
            node.matches.add(alias)  # matchesé›†åˆã«è¿½åŠ 
        del value["aliases"]         # å‡¦ç†æ¸ˆã¿ã‚¨ã‚¤ãƒªã‚¢ã‚¹å‰Šé™¤
```

#### BFSæ¢ç´¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
```python
def find_nearest_key_node(node: ConfigNode, key: str) -> list[ConfigNode]:
    queue = deque([(0, node)])      # (æ·±åº¦, ãƒãƒ¼ãƒ‰) ã®ã‚­ãƒ¥ãƒ¼
    visited = set()                 # è¨ªå•æ¸ˆã¿ãƒãƒ¼ãƒ‰ç®¡ç†
    find_depth = 1 << 31           # æœ€å°æ·±åº¦è¿½è·¡
    results = []                   # çµæœãƒãƒ¼ãƒ‰
    
    while queue:
        depth, current = queue.popleft()
        if depth > find_depth:     # æœ€å°æ·±åº¦ã‚’è¶…ãˆãŸã‚‰çµ‚äº†
            break
        if current in visited:
            continue
        visited.add(current)
        
        if key in current.matches: # ãƒãƒƒãƒãƒ³ã‚°åˆ¤å®š
            find_depth = min(find_depth, depth)
            results.append(current)
            
        for next_node in current.next_nodes:
            queue.append((depth + 1, next_node))
    
    return results
```

### ConfigResolver (è¨­å®šè§£æ±ºã‚¨ãƒ³ã‚¸ãƒ³)

#### æœ¨æ§‹é€ æ§‹ç¯‰ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
```python
def create_config_root_from_dict(data: dict) -> ConfigNode:
    root = ConfigNode('root', data)
    init_matches(root, data)
    queue = [(root, data)]
    
    while queue:
        parent, current_data = queue.pop()
        
        if isinstance(current_data, dict):
            for key, value in current_data.items():
                if key == "aliases":
                    continue  # ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã¯æ—¢ã«å‡¦ç†æ¸ˆã¿
                
                node = ConfigNode(key, value)
                init_matches(node, value)
                add_edge(parent, node)        # è¦ªå­é–¢ä¿‚æ§‹ç¯‰
                queue.append((node, value))
```

#### å„ªå…ˆåº¦ä»˜ããƒãƒƒãƒãƒ³ã‚°ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
```python
def _resolve_by_match_desc(root: ConfigNode, path: tuple) -> list[ConfigNode]:
    results = []
    queue = [(path, 1, root)]  # (æ®‹ã‚Šãƒ‘ã‚¹, ãƒãƒƒãƒãƒ©ãƒ³ã‚¯, ãƒãƒ¼ãƒ‰)
    
    while queue:
        current_path, match_rank, node = queue.pop()
        
        for next_node in node.next_nodes:
            matched = False
            for i in range(len(current_path)):
                if current_path[i] in next_node.matches:
                    matched = True
                    # ãƒ“ãƒƒãƒˆã‚·ãƒ•ãƒˆã«ã‚ˆã‚‹å„ªå…ˆåº¦è¨ˆç®—
                    new_rank = match_rank + (1 << (len(original_path) - i))
                    queue.append((current_path[i+1:], new_rank, next_node))
                    results.append((new_rank, next_node))
    
    # å„ªå…ˆåº¦é †ã§ã‚½ãƒ¼ãƒˆ
    results.sort(key=lambda x: x[0], reverse=True)
    return [node for _, node in results]
```

### ConfigManager (é«˜ãƒ¬ãƒ™ãƒ«API)

#### å‹å®‰å…¨ãªè¨­å®šã‚¢ã‚¯ã‚»ã‚¹
```python
def get(self, path: Union[str, List[str]], return_type: Type[T], default: Optional[T] = None) -> T:
    # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
    cache_key = (tuple(normalized_path), return_type)
    if cache_key in self._cache:
        return self._cache[cache_key]
    
    # è¨­å®šè§£æ±º
    node = resolve_best(self._root, normalized_path)
    if node is None:
        if default is not None:
            return default
        raise ConfigResolverError(f"Path not found: {path}")
    
    # å‹å¤‰æ›
    value = self._convert_value(node.value, return_type)
    
    # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¿å­˜
    self._cache[cache_key] = value
    return value
```

#### å‹å¤‰æ›ã‚·ã‚¹ãƒ†ãƒ 
```python
def _convert_value(self, value: Any, target_type: Type[T]) -> T:
    if target_type is str:
        return str(value)
    elif target_type is int:
        if isinstance(value, bool):
            raise ConfigValidationError("Cannot convert bool to int")
        return int(value)
    elif target_type is bool:
        if isinstance(value, bool):
            return value
        elif isinstance(value, str):
            if value.lower() in ('true', '1', 'yes', 'on'):
                return True
            elif value.lower() in ('false', '0', 'no', 'off'):
                return False
        raise ConfigValidationError(f"Cannot convert {value} to bool")
    # ... ä»–ã®å‹ã‚‚åŒæ§˜
```

## ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ä»•æ§˜

### æ™‚é–“è¨ˆç®—é‡

#### æœ¨æ§‹ç¯‰: O(n)
- n: è¨­å®šé …ç›®æ•°
- å„é …ç›®ã‚’1å›ãšã¤å‡¦ç†

#### è¨­å®šè§£æ±º: O(d Ã— b)
- d: æœ¨ã®æ·±åº¦
- b: å¹³å‡åˆ†å²æ•°
- BFSæ¢ç´¢ã«ã‚ˆã‚‹

#### ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆ: O(1)
- ãƒãƒƒã‚·ãƒ¥ãƒ†ãƒ¼ãƒ–ãƒ«ã«ã‚ˆã‚‹å®šæ•°æ™‚é–“ã‚¢ã‚¯ã‚»ã‚¹

### ç©ºé–“è¨ˆç®—é‡

#### æœ¨æ§‹é€ : O(n)
- n: è¨­å®šé …ç›®æ•°
- å„ãƒãƒ¼ãƒ‰ãŒä¸€å®šã®ãƒ¡ãƒ¢ãƒªã‚’ä½¿ç”¨

#### ã‚­ãƒ£ãƒƒã‚·ãƒ¥: O(k)  
- k: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸé …ç›®æ•°
- LRU ã«ã‚ˆã‚‹è‡ªå‹•å‰Šé™¤

### ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ä»•æ§˜

#### å°è¦æ¨¡è¨­å®š (< 100é …ç›®)
- è¨­å®šè§£æ±º: < 1ms
- ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡: < 1MB

#### ä¸­è¦æ¨¡è¨­å®š (< 1,000é …ç›®)
- è¨­å®šè§£æ±º: < 10ms
- ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡: < 10MB

#### å¤§è¦æ¨¡è¨­å®š (< 10,000é …ç›®)
- è¨­å®šè§£æ±º: < 100ms
- ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡: < 100MB

## ğŸ”’ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä»•æ§˜

### å…¥åŠ›æ¤œè¨¼

#### ãƒ‘ã‚¹æ¤œè¨¼
```python
def normalize_path(path: Union[str, List[str], tuple]) -> List[str]:
    # ãƒ‘ã‚¹å½¢å¼ã®æ¤œè¨¼
    if isinstance(path, str):
        if not path.strip():
            raise ConfigValidationError("Path cannot be empty")
        return [part.strip() for part in path.split('.') if part.strip()]
    # ãƒªã‚¹ãƒˆ/ã‚¿ãƒ—ãƒ«å½¢å¼ã®æ¤œè¨¼...
```

#### è¨­å®šæ§‹é€ æ¤œè¨¼
```python
def validate_config_structure(data: Any, allow_empty: bool = False) -> None:
    if data is None:
        raise ConfigValidationError("Configuration cannot be None")
    
    # äºˆç´„ã‚­ãƒ¼ã®ãƒã‚§ãƒƒã‚¯
    reserved_keys = {'__aliasconf_internal__', '__meta__'}
    for key in data:
        if key in reserved_keys:
            raise ConfigValidationError(f"Reserved key: {key}")
```

### ã‚¨ãƒ©ãƒ¼å‡¦ç†

#### ä¾‹å¤–éšå±¤
```
AliasConfError (åŸºåº•ä¾‹å¤–)
â”œâ”€â”€ ConfigNodeError (ãƒãƒ¼ãƒ‰æ“ä½œã‚¨ãƒ©ãƒ¼)
â”œâ”€â”€ ConfigResolverError (è§£æ±ºã‚¨ãƒ©ãƒ¼)
â””â”€â”€ ConfigValidationError (æ¤œè¨¼ã‚¨ãƒ©ãƒ¼)
```

#### ã‚¨ãƒ©ãƒ¼æƒ…å ±
- è©³ç´°ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
- å•é¡Œç®‡æ‰€ã®ç‰¹å®šæƒ…å ±
- ä¿®æ­£æ–¹æ³•ã®ææ¡ˆ

### ãƒ¡ãƒ¢ãƒªå®‰å…¨æ€§

#### å¾ªç’°å‚ç…§ã®é˜²æ­¢
```python
# è¨ªå•æ¸ˆã¿ãƒãƒ¼ãƒ‰ã®ç®¡ç†
visited = set()
if id(current) in visited:
    continue
visited.add(id(current))
```

#### ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†
- è‡ªå‹•çš„ãªã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³
- ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚ºã®åˆ¶é™
- ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã®é˜²æ­¢

## ğŸ§ª ãƒ†ã‚¹ãƒˆä»•æ§˜

### ãƒ†ã‚¹ãƒˆåˆ†é¡

#### Unit Tests (å˜ä½“ãƒ†ã‚¹ãƒˆ)
- **å¯¾è±¡**: å€‹åˆ¥é–¢æ•°ãƒ»ãƒ¡ã‚½ãƒƒãƒ‰
- **ã‚«ãƒãƒ¬ãƒƒã‚¸**: 90%ä»¥ä¸Š
- **å®Ÿè¡Œæ™‚é–“**: < 1ç§’

#### Integration Tests (çµ±åˆãƒ†ã‚¹ãƒˆ)
- **å¯¾è±¡**: ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«é–“é€£æº
- **ã‚«ãƒãƒ¬ãƒƒã‚¸**: ä¸»è¦æ©Ÿèƒ½100%
- **å®Ÿè¡Œæ™‚é–“**: < 10ç§’

#### Performance Tests (æ€§èƒ½ãƒ†ã‚¹ãƒˆ)
- **å¯¾è±¡**: ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“ãƒ»ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡
- **åŸºæº–**: ä¸Šè¨˜ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ä»•æ§˜
- **å®Ÿè¡Œé »åº¦**: ãƒªãƒªãƒ¼ã‚¹å‰

### ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

#### ã‚¨ã‚¤ãƒªã‚¢ã‚¹æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ
```python
def test_alias_resolution():
    config_dict = {
        "python": {
            "aliases": ["py", "python3"],
            "timeout": 30
        }
    }
    config = ConfigManager.from_dict(config_dict)
    
    # å…¨ã¦ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã§åŒã˜å€¤ãŒå–å¾—ã§ãã‚‹ã“ã¨ã‚’ç¢ºèª
    assert config.get("python.timeout", int) == 30
    assert config.get("py.timeout", int) == 30
    assert config.get("python3.timeout", int) == 30
```

#### å‹å¤‰æ›ãƒ†ã‚¹ãƒˆ
```python
def test_type_conversion():
    config_dict = {"value": "30"}
    config = ConfigManager.from_dict(config_dict)
    
    # æ­£å¸¸ãªå‹å¤‰æ›
    assert config.get("value", int) == 30
    assert config.get("value", str) == "30"
    
    # ä¸æ­£ãªå‹å¤‰æ›
    with pytest.raises(ConfigValidationError):
        config.get("value", bool)
```

## ğŸ“š API ä»•æ§˜

### ConfigManager

#### ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
```python
def __init__(self, root_node: Optional[ConfigNode] = None)
```

#### ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰
```python
@classmethod
def from_dict(cls, data: Dict[str, Any]) -> 'ConfigManager'

@classmethod  
def from_file(cls, file_path: Union[str, Path]) -> 'ConfigManager'

@classmethod
def from_files(cls, *file_paths: Union[str, Path]) -> 'ConfigManager'
```

#### ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰
```python
def get(self, path: Union[str, List[str]], return_type: Type[T], default: Optional[T] = None) -> T

def get_all(self, path: Union[str, List[str]], return_type: Type[T]) -> List[T]

def has(self, path: Union[str, List[str]]) -> bool

def get_formatted(self, path: Union[str, List[str]], context: Optional[Dict[str, Any]] = None, return_type: Type[T] = str) -> T

def merge(self, other: 'ConfigManager') -> 'ConfigManager'

def to_dict(self, include_aliases: bool = False) -> Dict[str, Any]

def clear_cache(self) -> None
```

## ğŸ”§ æ‹¡å¼µä»•æ§˜

### ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ  (å°†æ¥å®Ÿè£…)

#### ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¤ãƒ³ã‚¿ãƒ¼face
```python
class ConfigPlugin:
    def on_load(self, config_data: dict) -> dict:
        """è¨­å®šèª­ã¿è¾¼ã¿æ™‚ã®å‡¦ç†"""
        pass
    
    def on_resolve(self, path: List[str], value: Any) -> Any:
        """è¨­å®šè§£æ±ºæ™‚ã®å‡¦ç†"""
        pass
```

#### ã‚«ã‚¹ã‚¿ãƒ ãƒ­ãƒ¼ãƒ€ãƒ¼
```python
class CustomLoader:
    def load(self, source: str) -> dict:
        """ã‚«ã‚¹ã‚¿ãƒ å½¢å¼ã®è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿"""
        pass
```

### ç’°å¢ƒå¤‰æ•°çµ±åˆ (å°†æ¥å®Ÿè£…)
```python
config = ConfigManager.from_dict({
    "database": {
        "host": "${DB_HOST:localhost}",  # ç’°å¢ƒå¤‰æ•°å‚ç…§
        "port": "${DB_PORT:5432}"
    }
})
```

## ğŸ“ˆ ç›£è¦–ãƒ»ãƒ­ã‚°ä»•æ§˜

### ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«
- **DEBUG**: è©³ç´°ãªå†…éƒ¨å‹•ä½œ
- **INFO**: ä¸€èˆ¬çš„ãªæƒ…å ±
- **WARNING**: è­¦å‘Šäº‹é …
- **ERROR**: ã‚¨ãƒ©ãƒ¼æƒ…å ±

### ãƒ¡ãƒˆãƒªã‚¯ã‚¹
- è¨­å®šè§£æ±ºæ™‚é–“
- ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆç‡
- ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡
- APIå‘¼ã³å‡ºã—å›æ•°

## ğŸ”„ ãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°

### ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯ãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°
- **MAJOR**: ç ´å£Šçš„å¤‰æ›´
- **MINOR**: æ©Ÿèƒ½è¿½åŠ 
- **PATCH**: ãƒã‚°ä¿®æ­£

### äº’æ›æ€§ãƒãƒªã‚·ãƒ¼
- v1.0.0ã¾ã§: APIã®å¤§å¹…å¤‰æ›´ã‚ã‚Š
- v1.0.0ä»¥é™: å¾Œæ–¹äº’æ›æ€§ä¿è¨¼

---

**ä½œæˆè€…**: AliasConf Development Team  
**ãƒ¬ãƒ“ãƒ¥ãƒ¼**: 2024å¹´7æœˆ10æ—¥äºˆå®š  
**æ‰¿èª**: é–‹ç™ºãƒãƒ¼ãƒ ãƒªãƒ¼ãƒ€ãƒ¼æ‰¿èªå¾…ã¡